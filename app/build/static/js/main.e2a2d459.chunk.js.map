{"version":3,"sources":["CandyMachine/index.js","CandyMachine/connection.js","CountdownTimer/index.js","assets/twitter-logo.svg","App.js","index.js","CandyMachine/helpers.js"],"names":["SystemProgram","web3","opts","CandyMachine","walletAddress","useState","candyMachine","setCandyMachine","isMinting","setIsMinting","getCandyMachineCreator","a","candyMachineID","PublicKey","findProgramAddress","Buffer","from","toBuffer","candyMachineProgram","getMetadata","mint","TOKEN_METADATA_PROGRAM_ID","getMasterEdition","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","splTokenMintAddress","keys","pubkey","isSigner","isWritable","programId","TOKEN_PROGRAM_ID","SYSVAR_RENT_PUBKEY","TransactionInstruction","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","data","getProvider","connection","Connection","process","Provider","window","solana","getCandyMachineState","provider","Program","fetchIdl","idl","program","account","fetch","itemsAvailable","toNumber","itemsRedeemed","itemsRemaining","goLiveData","goLiveDate","presale","whitelistMintSettings","Date","getTime","goLiveDateTimeString","toLocaleDateString","toLocaleTimeString","console","log","id","state","isSoldOut","isActive","endSettings","endSettingType","date","number","isPresale","treasury","wallet","tokenMint","gatekeeper","hiddenSettings","price","mintToken","Keypair","generate","getAtaForMint","publicKey","userTokenAccountAddress","userPayingAccountAddress","candyMachineAddress","remainingAccounts","signers","cleanupInstructions","MintLayout","span","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","lamports","createAccount","Token","createInitMintInstruction","createMintToInstruction","instructions","getNetworkToken","gatekeeperNetwork","push","expireOnUse","CIVIC","getNetworkExpire","whitelistToken","mode","burnEveryTime","whitelistBurnAuthority","getAccountInfo","createApproveInstruction","createRevokeInstruction","transferAuthority","metadataAddress","masterEdition","candyMachineCreator","creatorBump","instruction","mintNft","accounts","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_RECENT_BLOCKHASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","length","undefined","sendTransactions","txs","map","t","txid","useEffect","className","currentDate","dropDate","renderDropTimer","onClick","disabled","instructionSet","signersSet","sequenceType","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","i","transaction","Transaction","forEach","add","recentBlockhash","blockhash","setSigners","s","partialSign","signAllTransactions","signedTxns","pendingTxns","breakEarlyObject","breakEarly","signedTxnPromise","sendSignedTransaction","signedTransaction","then","slot","catch","reason","Promise","all","getUnixTs","DEFAULT_TIMEOUT","timeout","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","done","sleep","awaitTransactionSignatureConfirmation","confirmation","Error","err","error","simulateResult","simulateTransaction","value","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","message","result","queryStatus","status","confirmations","subId","resolve","reject","setTimeout","onSignature","context","e","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms","CountdownTimer","timerString","setTimerString","interval","setInterval","distance","days","Math","floor","hours","minutes","seconds","clearInterval","TWITTER_HANDLE","TWITTER_LINK","App","setWalletAddress","checkIfWalletIsConnected","isPhantom","connect","onlyIfTrusted","response","alert","connectWallet","onLoad","addEventListener","removeEventListener","alt","src","twitterLogo","href","target","rel","ReactDOM","render","StrictMode","document","getElementById","anchor","Intl","NumberFormat","style","minimumFractionDigits","maximumFractionDigits","buyer"],"mappings":"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","file":"static/js/main.e2a2d459.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport { Connection, PublicKey } from '@solana/web3.js';\nimport { Program, Provider, web3 } from '@project-serum/anchor';\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\nimport { sendTransactions } from './connection';\nimport './CandyMachine.css';\nimport {\n  candyMachineProgram,\n  TOKEN_METADATA_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken,\n  CIVIC\n} from './helpers';\nimport CountdownTimer from '../CountdownTimer';\n\nconst { SystemProgram } = web3;\nconst opts = {\n  preflightCommitment: 'processed',\n};\n\nconst CandyMachine = ({ walletAddress }) => {\n  const [candyMachine, setCandyMachine] = useState(null);\n  const [isMinting, setIsMinting] = useState(false);\n\n  const getCandyMachineCreator = async (candyMachine) => {\n    const candyMachineID = new PublicKey(candyMachine);\n    return await web3.PublicKey.findProgramAddress(\n      [Buffer.from('candy_machine'), candyMachineID.toBuffer()],\n      candyMachineProgram,\n    );\n  };\n\n  const getMetadata = async (mint) => {\n    return (\n      await PublicKey.findProgramAddress(\n        [\n          Buffer.from('metadata'),\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n          mint.toBuffer(),\n        ],\n        TOKEN_METADATA_PROGRAM_ID\n      )\n    )[0];\n  };\n\n  const getMasterEdition = async (mint) => {\n    return (\n      await PublicKey.findProgramAddress(\n        [\n          Buffer.from('metadata'),\n          TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n          mint.toBuffer(),\n          Buffer.from('edition'),\n        ],\n        TOKEN_METADATA_PROGRAM_ID\n      )\n    )[0];\n  };\n\n  const createAssociatedTokenAccountInstruction = (\n    associatedTokenAddress,\n    payer,\n    walletAddress,\n    splTokenMintAddress\n  ) => {\n    const keys = [\n      { pubkey: payer, isSigner: true, isWritable: true },\n      { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n      { pubkey: walletAddress, isSigner: false, isWritable: false },\n      { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n      {\n        pubkey: web3.SystemProgram.programId,\n        isSigner: false,\n        isWritable: false,\n      },\n      { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n      {\n        pubkey: web3.SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false,\n      },\n    ];\n    return new web3.TransactionInstruction({\n      keys,\n      programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n      data: Buffer.from([]),\n    });\n  };\n\n  const getProvider = () => {\n    const rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST;\n    // Create a new connection object\n    const connection = new Connection(rpcHost);\n\n    // Create a new Solana provider object\n    const provider = new Provider(\n      connection,\n      window.solana,\n      opts.preflightCommitment\n    );\n\n    return provider;\n  };\n\n  // ãã®1\n  // ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°é–¢æ•°ã‚’ä½œæˆã—ã¾ã™\n  const renderDropTimer = () => {\n    // JavaScriptã®Dateã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã§ç¾åœ¨ã®æ—¥ä»˜ã¨DropDateã‚’å–å¾—ã—ã¾ã™\n    const currentDate = new Date();\n    const dropDate = new Date(candyMachine.state.goLiveData * 1000);\n\n    // ã‚‚ã—ç¾åœ¨ã®æ—¥æ™‚ãŒãƒ‰ãƒ­ãƒƒãƒ—æ—¥ã‚ˆã‚Šã‚‚å‰ã®å ´åˆã€ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã—ã¾ã™\n    if (currentDate < dropDate) {\n      console.log('Before drop date!');\n      // ãƒ‰ãƒ­ãƒƒãƒ—æ—¥ã‚’è¿”ã—ã¾ã™\n      return <CountdownTimer dropDate={dropDate} />;\n    }\n\n    // æ¡ä»¶ã«æº€ãŸãªã„å ´åˆã¯ãƒ‰ãƒ­ãƒƒãƒ—æ—¥ã®ã¿ã‚’è¿”ã—ã¾ã™\n    return <p>{`Drop Date: ${candyMachine.state.goLiveDateTimeString}`}</p>;\n  };\n\n  const getCandyMachineState = async () => {\n    const provider = getProvider();\n\n    // Get metadata about your deployed candy machine program\n    const idl = await Program.fetchIdl(candyMachineProgram, provider);\n\n    // Create a program that you can call\n    const program = new Program(idl, candyMachineProgram, provider);\n\n    const candyMachine = await program.account.candyMachine.fetch(\n      process.env.REACT_APP_CANDY_MACHINE_ID\n    );\n    const itemsAvailable = candyMachine.data.itemsAvailable.toNumber();\n    const itemsRedeemed = candyMachine.itemsRedeemed.toNumber();\n    const itemsRemaining = itemsAvailable - itemsRedeemed;\n    const goLiveData = candyMachine.data.goLiveDate.toNumber();\n\n    const presale =\n      candyMachine.data.whitelistMintSettings &&\n      candyMachine.data.whitelistMintSettings.presale &&\n      (!candyMachine.data.goLiveDate ||\n        candyMachine.data.goLiveDate.toNumber() > new Date().getTime() / 1000);\n\n    // We will be using this later in our UI so let's generate this now\n    const goLiveDateTimeString = `${new Date(\n      goLiveData * 1000\n    ).toLocaleDateString()} @ ${new Date(\n      goLiveData * 1000\n    ).toLocaleTimeString()}`;\n\n    console.log({\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      goLiveData,\n      goLiveDateTimeString,\n      presale,\n    });\n\n    // Add this data to your state to render\n    setCandyMachine({\n      id: process.env.REACT_APP_CANDY_MACHINE_ID,\n      program,\n      state: {\n        itemsAvailable,\n        itemsRedeemed,\n        itemsRemaining,\n        goLiveData,\n        goLiveDateTimeString,\n        isSoldOut: itemsRemaining === 0,\n        isActive:\n          (presale ||\n            candyMachine.data.goLiveDate.toNumber() < new Date().getTime() / 1000) &&\n          (candyMachine.endSettings\n            ? candyMachine.endSettings.endSettingType.date\n              ? candyMachine.endSettings.number.toNumber() > new Date().getTime() / 1000\n              : itemsRedeemed < candyMachine.endSettings.number.toNumber()\n            : true),\n        isPresale: presale,\n        goLiveDate: candyMachine.data.goLiveDate,\n        treasury: candyMachine.wallet,\n        tokenMint: candyMachine.tokenMint,\n        gatekeeper: candyMachine.data.gatekeeper,\n        endSettings: candyMachine.data.endSettings,\n        whitelistMintSettings: candyMachine.data.whitelistMintSettings,\n        hiddenSettings: candyMachine.data.hiddenSettings,\n        price: candyMachine.data.price,\n      },\n    });\n  };\n\n  const mintToken = async () => {\n    setIsMinting(true);\n    const mint = web3.Keypair.generate();\n\n    const userTokenAccountAddress = (\n      await getAtaForMint(mint.publicKey, walletAddress.publicKey)\n    )[0];\n\n    const userPayingAccountAddress = candyMachine.state.tokenMint\n      ? (await getAtaForMint(candyMachine.state.tokenMint, walletAddress.publicKey))[0]\n      : walletAddress.publicKey;\n\n    const candyMachineAddress = candyMachine.id;\n    const remainingAccounts = [];\n    const signers = [mint];\n    const cleanupInstructions = [];\n    const instructions = [\n      web3.SystemProgram.createAccount({\n        fromPubkey: walletAddress.publicKey,\n        newAccountPubkey: mint.publicKey,\n        space: MintLayout.span,\n        lamports:\n          await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\n            MintLayout.span,\n          ),\n        programId: TOKEN_PROGRAM_ID,\n      }),\n      Token.createInitMintInstruction(\n        TOKEN_PROGRAM_ID,\n        mint.publicKey,\n        0,\n        walletAddress.publicKey,\n        walletAddress.publicKey,\n      ),\n      createAssociatedTokenAccountInstruction(\n        userTokenAccountAddress,\n        walletAddress.publicKey,\n        walletAddress.publicKey,\n        mint.publicKey,\n      ),\n      Token.createMintToInstruction(\n        TOKEN_PROGRAM_ID,\n        mint.publicKey,\n        userTokenAccountAddress,\n        walletAddress.publicKey,\n        [],\n        1,\n      ),\n    ];\n\n    if (candyMachine.state.gatekeeper) {\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkToken(\n            walletAddress.publicKey,\n            candyMachine.state.gatekeeper.gatekeeperNetwork,\n          )\n        )[0],\n        isWritable: true,\n        isSigner: false,\n      });\n      if (candyMachine.state.gatekeeper.expireOnUse) {\n        remainingAccounts.push({\n          pubkey: CIVIC,\n          isWritable: false,\n          isSigner: false,\n        });\n        remainingAccounts.push({\n          pubkey: (\n            await getNetworkExpire(\n              candyMachine.state.gatekeeper.gatekeeperNetwork,\n            )\n          )[0],\n          isWritable: false,\n          isSigner: false,\n        });\n      }\n    }\n    if (candyMachine.state.whitelistMintSettings) {\n      const mint = new web3.PublicKey(\n        candyMachine.state.whitelistMintSettings.mint,\n      );\n\n      const whitelistToken = (await getAtaForMint(mint, walletAddress.publicKey))[0];\n      remainingAccounts.push({\n        pubkey: whitelistToken,\n        isWritable: true,\n        isSigner: false,\n      });\n\n      if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n        const whitelistBurnAuthority = web3.Keypair.generate();\n\n        remainingAccounts.push({\n          pubkey: mint,\n          isWritable: true,\n          isSigner: false,\n        });\n        remainingAccounts.push({\n          pubkey: whitelistBurnAuthority.publicKey,\n          isWritable: false,\n          isSigner: true,\n        });\n        signers.push(whitelistBurnAuthority);\n        const exists =\n          await candyMachine.program.provider.connection.getAccountInfo(\n            whitelistToken,\n          );\n        if (exists) {\n          instructions.push(\n            Token.createApproveInstruction(\n              TOKEN_PROGRAM_ID,\n              whitelistToken,\n              whitelistBurnAuthority.publicKey,\n              walletAddress.publicKey,\n              [],\n              1,\n            ),\n          );\n          cleanupInstructions.push(\n            Token.createRevokeInstruction(\n              TOKEN_PROGRAM_ID,\n              whitelistToken,\n              walletAddress.publicKey,\n              [],\n            ),\n          );\n        }\n      }\n    }\n\n    if (candyMachine.state.tokenMint) {\n      const transferAuthority = web3.Keypair.generate();\n\n      signers.push(transferAuthority);\n      remainingAccounts.push({\n        pubkey: userPayingAccountAddress,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: transferAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n\n      instructions.push(\n        Token.createApproveInstruction(\n          TOKEN_PROGRAM_ID,\n          userPayingAccountAddress,\n          transferAuthority.publicKey,\n          walletAddress.publicKey,\n          [],\n          candyMachine.state.price.toNumber(),\n        ),\n      );\n      cleanupInstructions.push(\n        Token.createRevokeInstruction(\n          TOKEN_PROGRAM_ID,\n          userPayingAccountAddress,\n          walletAddress.publicKey,\n          [],\n        ),\n      );\n    }\n    const metadataAddress = await getMetadata(mint.publicKey);\n    const masterEdition = await getMasterEdition(mint.publicKey);\n\n    const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\n      candyMachineAddress,\n    );\n\n    instructions.push(\n      await candyMachine.program.instruction.mintNft(creatorBump, {\n        accounts: {\n          candyMachine: candyMachineAddress,\n          candyMachineCreator,\n          payer: walletAddress.publicKey,\n          wallet: candyMachine.state.treasury,\n          mint: mint.publicKey,\n          metadata: metadataAddress,\n          masterEdition,\n          mintAuthority: walletAddress.publicKey,\n          updateAuthority: walletAddress.publicKey,\n          tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n          tokenProgram: TOKEN_PROGRAM_ID,\n          systemProgram: SystemProgram.programId,\n          rent: web3.SYSVAR_RENT_PUBKEY,\n          clock: web3.SYSVAR_CLOCK_PUBKEY,\n          recentBlockhashes: web3.SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          instructionSysvarAccount: web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n        },\n        remainingAccounts:\n          remainingAccounts.length > 0 ? remainingAccounts : undefined,\n      }),\n    );\n\n    try {\n      setIsMinting(false);\n      return (\n        await sendTransactions(\n          candyMachine.program.provider.connection,\n          candyMachine.program.provider.wallet,\n          [instructions, cleanupInstructions],\n          [signers, []],\n        )\n      ).txs.map(t => t.txid);\n    } catch (e) {\n      console.log(e);\n    }\n    setIsMinting(false);\n    return [];\n  };\n\n  useEffect(() => {\n    getCandyMachineState();\n  }, []);\n\n  return (\n    candyMachine && (\n      <div className=\"machine-container\">\n        {renderDropTimer()}\n        <p>{`Items Minted: ${candyMachine.state.itemsRedeemed} / ${candyMachine.state.itemsAvailable}`}</p>\n        {/*  ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒç­‰ã—ã„ã‹ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ */}\n        {candyMachine.state.itemsRedeemed === candyMachine.state.itemsAvailable ? (\n          <p className=\"sub-text\">Sold Out ğŸ™Š</p>\n        ) : (\n          <button\n            className=\"cta-button mint-button\"\n            onClick={mintToken}\n            disabled={isMinting}\n          >\n            Mint NFT\n          </button>\n        )}\n      </div>\n    )\n  );\n};\n\nexport default CandyMachine;\n","import { Transaction } from '@solana/web3.js';\n\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n\nexport const getErrorForTransaction = async (\n  connection,\n  txid\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\n\nexport async function sendTransactionsWithManualRetry(\n  connection,\n  wallet,\n  instructions,\n  signers,\n){\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          'single',\n        );\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const { txs } = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          'StopOnFailure',\n          'single',\n        );\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      'Died on ',\n      stopPoint,\n      'retrying from instruction',\n      instructions[stopPoint],\n      'instructions length is',\n      instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\n\nexport const sendTransactions = async (\n  connection,\n  wallet,\n  instructionSet,\n  signersSet,\n  sequenceType = 'Parallel',\n  commitment = 'singleGossip',\n  successCallback = (txid, ind) => {},\n  failCallback = (txid, ind) => false,\n  block,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns = [];\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n\n  const signedTxns = await wallet.signAllTransactions(unsignedTxns);\n\n  const pendingTxns= [];\n\n  let breakEarlyObject = { breakEarly: false, i: 0 };\n  console.log(\n    'Signed txns length',\n    signedTxns.length,\n    'vs handed in length',\n    instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    signedTxnPromise\n      .then(({ txid, slot }) => {\n        successCallback(txid, i);\n      })\n      .catch(reason => {\n        failCallback(signedTxns[i], i);\n        if (sequenceType === 'StopOnFailure') {\n          breakEarlyObject.breakEarly = true;\n          breakEarlyObject.i = i;\n        }\n      });\n\n    if (sequenceType !== 'Parallel') {\n      try {\n        await signedTxnPromise;\n      } catch (e) {\n        console.log('Caught failure', e);\n        if (breakEarlyObject.breakEarly) {\n          console.log('Died on ', breakEarlyObject.i);\n          // Return the txn we failed on by index\n          return {\n            number: breakEarlyObject.i,\n            txs: await Promise.all(pendingTxns),\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== 'Parallel') {\n    await Promise.all(pendingTxns);\n  }\n\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n  connection,\n  wallet,\n  instructions,\n  signers,\n  awaitConfirmation = true,\n  commitment = 'singleGossip',\n  includesFeePayer = false,\n  block,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection,\n  wallet,\n  instructions,\n  signers,\n  commitment = 'singleGossip',\n  includesFeePayer = false,\n  block,\n  beforeSend,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}) {\n  const rawTransaction = signedTransaction.serialize();\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'recent',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection,\n  transaction,\n  commitment,\n) {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid,\n  timeout,\n  connection,\n  commitment = 'recent',\n  queryStatus = false,\n){\n  let done = false;\n  let status = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            console.log('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import React, { useEffect, useState } from 'react';\nimport './CountdownTimer.css';\n\nconst CountdownTimer = ({ dropDate }) => {\n\t// State\n\tconst [timerString, setTimerString] = useState('');\n\n\t// Our useEffect will run on comppnent load\n\tuseEffect(() => {\n\t\tconsole.log('Setting interval...');\n\n\t\t// Use setInterval to run this piece of code every second\n\t\tconst interval = setInterval(() => {\n\t\t\tconst currentDate = new Date().getTime();\n\t\t\tconst distance = dropDate - currentDate;\n\n\t\t\t// Here it's as easy as doing some time math to get the different properties\n\t\t\tconst days = Math.floor(distance / (1000 * 60 * 60 * 24));\n\t\t\tconst hours = Math.floor(\n\t\t\t\t(distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60)\n\t\t\t);\n\t\t\tconst minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));\n\t\t\tconst seconds = Math.floor((distance % (1000 * 60)) / 1000);\n\n\t\t\t// We have our desired output, set it in state!\n\t\t\tsetTimerString(`${days}d ${hours}h ${minutes}m ${seconds}s`);\n\n\t\t\t// If our distance passes zero this means that it's drop time!\n\t\t\tif (distance < 0) {\n\t\t\t\tconsole.log('Clearing interval...');\n\t\t\t\tclearInterval(interval);\n\t\t\t}\n\t\t}, 1000);\n\n\t\t// Anytime our component unmounts let's clean up our interval\n\t\treturn () => {\n\t\t\tif (interval) {\n\t\t\t\tclearInterval(interval);\n\t\t\t}\n\t\t};\n\t}, []);\n\n\treturn (\n\t\t<div className=\"timer-container\">\n\t\t\t<p className=\"timer-header\">Candy Drop Starting In</p>\n\t\t\t{timerString && <p className=\"timer-value\">{`â° ${timerString}`}</p>}\n\t\t</div>\n\t);\n};\n\nexport default CountdownTimer;\n","export default __webpack_public_path__ + \"static/media/twitter-logo.d89d9a86.svg\";","import React, { useEffect, useState } from 'react';\nimport './App.css';\nimport twitterLogo from './assets/twitter-logo.svg';\nimport CandyMachine from './CandyMachine';\n// Constants\nconst TWITTER_HANDLE = 'ta_ka_sea0';\nconst TWITTER_LINK = `https://twitter.com/${TWITTER_HANDLE}`;\n\nconst App = () => {\n  // State\n  const [walletAddress, setWalletAddress] = useState(null);\n\n  // Actions\n  const checkIfWalletIsConnected = async () => {\n    try {\n      const { solana } = window;\n\n      if (solana) {\n        if (solana.isPhantom) {\n          console.log('Phantom wallet found!');\n          const response = await solana.connect({ onlyIfTrusted: true });\n          console.log(\n            'Connected with Public Key:',\n            response.publicKey.toString()\n          );\n\n          /*\n           * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å…¬é–‹éµã‚’å¾Œã‹ã‚‰ä½¿ãˆã‚‹çŠ¶æ…‹ã«ã—ã¾ã™ã€‚\n           */\n          setWalletAddress(response.publicKey.toString());\n        }\n      } else {\n        alert('Solana object not found! Get a Phantom Wallet ğŸ‘»');\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  };\n\n  const connectWallet = async () => {\n    const { solana } = window;\n\n    if (solana) {\n      const response = await solana.connect();\n      console.log('Connected with Public Key:', response.publicKey.toString());\n      setWalletAddress(response.publicKey.toString());\n    }\n  };\n\n  const renderNotConnectedContainer = () => (\n    <button\n      className=\"cta-button connect-wallet-button\"\n      onClick={connectWallet}\n    >\n      Connect to Wallet\n    </button>\n  );\n\n  useEffect(() => {\n    const onLoad = async () => {\n      await checkIfWalletIsConnected();\n    };\n    window.addEventListener('load', onLoad);\n    return () => window.removeEventListener('load', onLoad);\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <div className=\"container\">\n        <div className=\"header-container\">\n          <p className=\"header\">ğŸ­ Candy Drop</p>\n          <p className=\"sub-text\">NFT drop machine with fair mint</p>\n          {/* ã‚¦ã‚©ãƒ¬ãƒƒãƒˆã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒã£ã¦ã„ãªã„å ´åˆã«ã®ã¿è¡¨ç¤ºã™ã‚‹æ¡ä»¶ã‚’è¿½åŠ ã™ã‚‹ */}\n          {!walletAddress && renderNotConnectedContainer()}\n        </div>\n        {/* Check for walletAddress and then pass in walletAddress */}\n        {walletAddress && <CandyMachine walletAddress={window.solana} />}\n        <div className=\"footer-container\">\n          <img alt=\"Twitter Logo\" className=\"twitter-logo\" src={twitterLogo} />\n          <a\n            className=\"footer-text\"\n            href={TWITTER_LINK}\n            target=\"_blank\"\n            rel=\"noreferrer\"\n          >{`built on @${TWITTER_HANDLE}`}</a>\n        </div>\n      </div>\n    </div>\n  );\n};\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n","import { web3 } from '@project-serum/anchor';\nimport * as anchor from '@project-serum/anchor';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport {\n  LAMPORTS_PER_SOL,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\n\n// CLI Properties Given to us\nconst candyMachineProgram = new web3.PublicKey(\n  'cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ'\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new web3.PublicKey(\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'\n);\n\nconst SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new web3.PublicKey(\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'\n);\n\nconst CIVIC = new anchor.web3.PublicKey(\n  'gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs',\n);\n\nconst toDate = (value) => {\n  if (!value) {\n    return;\n  }\n\n  return new Date(value.toNumber() * 1000);\n};\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nconst formatNumber = {\n  format: (val) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n  asNumber: (val) => {\n    if (!val) {\n      return undefined;\n    }\n\n    return val.toNumber() / LAMPORTS_PER_SOL;\n  },\n};\n\nconst getAtaForMint = async (mint, buyer)=> {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  );\n};\n\nconst getNetworkExpire = async (gatekeeperNetwork) => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [gatekeeperNetwork.toBuffer(), Buffer.from('expire')],\n    CIVIC,\n  );\n};\n\nconst getNetworkToken = async (wallet, gatekeeperNetwork) => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [\n      wallet.toBuffer(),\n      Buffer.from('gateway'),\n      Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\n      gatekeeperNetwork.toBuffer(),\n    ],\n    CIVIC,\n  );\n};\n\nfunction createAssociatedTokenAccountInstruction(\n  associatedTokenAddress,\n  payer,\n  walletAddress,\n  splTokenMintAddress,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n}\n\nexport {\n  candyMachineProgram,\n  TOKEN_METADATA_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  CIVIC,\n  toDate,\n  formatNumber,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken,\n  createAssociatedTokenAccountInstruction,\n};\n"],"sourceRoot":""}